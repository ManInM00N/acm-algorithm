## 启发式合并

对于维护的信息$info$
第一次先遍历所有 **轻儿子** ,直接求解不维护$info$
第二次遍历重儿子,求解的同时修改$info$
第三次再次遍历所有 **轻儿子** , 修改(清空)$info$

```cpp
mson[0] = 1;// 此处为了判别对轻儿子清除,不使用额外变量,而是比较父亲的重儿子是不是自己,故设置0的重儿子为1
ll ans
auto dfs3 = [&](auto self, ll u, ll f) -> void {
    // 优先轻儿子
    for (int i = h[u]; ~i; i = e[i].next) {
        ll v = e[i].to;
        if (v != f && mson[u] != v) {
            self(self, v, u);
        }
    }
    // 然后再重儿子
    if (mson[u]) {
        self(self, mson[u], u);
    }
    // 正常求解
    repi(i, dfn[u], dfn[u] + siz[u]) {
        // 遇到重儿子,跳过该子树
        if (i == dfn[mson[u]]) {
            i += siz[mson[u]];
            if (i >= dfn[u] + siz[u]) {
                break;
            }
        }
        /*
        	更新树状数组/线段树/数组,求解
        */
    }
    res[u] += tot;
    // 清空轻儿子
    if (mson[f] != u) {
        ans = 0;
        repi(i, dfn[u], dfn[u] + siz[u]) {
            /*
                清空记录的数据结构
            */
        }
    }
};
```

