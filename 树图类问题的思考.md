## 直径的性质

对于树上动态维护直径，类似[捉迷藏](https://www.luogu.com.cn/problem/P2056)，节点存在有效期，对于一个集合 $S$ 和只有一个点的集合 $\{𝑃\}$。若集合 $S$ 的直径为 $(𝑈,𝑉)$。则点集 $𝑆∩\{𝑃\}$ 的直径只可能为 $(𝑈,𝑉)$,$(U,P)$ 或 $(𝑉,𝑃)$，故在加入点时可以用最多两次$lca$,更新直径,直径为$len = dep[rt1] + dep[rt2] - 2*dep[lca(rt1,rt2)]$

## 启发式合并

对于维护的信息$info$
第一次先遍历所有 **轻儿子** ,直接求解不维护$info$
第二次遍历重儿子,求解的同时修改$info$
第三次再次遍历所有 **轻儿子** , 修改(清空)$info$

```cpp
mson[0] = 1;// 此处为了判别对轻儿子清除,不使用额外变量,而是比较父亲的重儿子是不是自己,故设置0的重儿子为1
ll ans
auto dfs3 = [&](auto self, ll u, ll f) -> void {
    // 优先轻儿子
    for (int i = h[u]; ~i; i = e[i].next) {
        ll v = e[i].to;
        if (v != f && mson[u] != v) {
            self(self, v, u);
        }
    }
    // 然后再重儿子
    if (mson[u]) {
        self(self, mson[u], u);
    }
    // 正常求解
    repi(i, dfn[u], dfn[u] + siz[u]) {
        // 遇到重儿子,跳过该子树
        if (i == dfn[mson[u]]) {
            i += siz[mson[u]];
            if (i >= dfn[u] + siz[u]) {
                break;
            }
        }
        /*
        	更新树状数组/线段树/数组,求解
        */
    }
    res[u] += tot;
    // 清空轻儿子
    if (mson[f] != u) {
        ans = 0;
        repi(i, dfn[u], dfn[u] + siz[u]) {
            /*
                清空记录的数据结构
            */
        }
    }
};
```

## 线段树分治

**线段树分治**多数情况似乎是和**可撤回并查集**一起
套路甚至大多为线段树存储**边**的**有效期**，即以**时间/距离**作为线段树的范围，以模拟线段树遍历的形式，更新可撤回并查集

```cpp
auto dfs = [&](auto self, ll p) -> void {
        ll siz = dsu.limit;// 记录此时大小，以保证回滚
        for (auto v : seg.tr[p].dir) {// 并入此时有效的边，有效范围 [tr[p].l,tr[p].r]
            auto [x, y] = ee[v];
            dsu.merge(x, y);
            /*
            	计算答案贡献
            */
        }
        if (seg.tr[p].l != seg.tr[p].r) {
            self(self, p << 1);
            self(self, p << 1 | 1);
        }
    	// dsu.roll_back(dsu.limit - siz);
        while (dsu.limit > siz) {// 回滚i只在 [tr[p].l,tr[p].r]有效的边
            Pa res;
            ll x = dsu.stk.top();
            dsu.stk.pop();
            dsu.limit--;
            /*
            	回滚贡献
            */
            dsu.siz[dsu.f[x]] -= dsu.siz[x];
            dsu.f[x] = x;
        }
    };

```

考虑对查询条件或范围进行建树，[连通图](https://www.luogu.com.cn/problem/P5227) 就是考虑对查询数量进行建树，考虑对边的有效范围就是$update$  
而 [Unique Occurrences](https://codeforces.com/problemset/problem/1681/F) 中，是查询仅出现**一次的边权**的路径数，那么可以以总的**边权范围**建树，将边放在除了他以外的边权节点上，到叶节点部分时，只要遍历该权值边两端**连通块**的积即可。
在$RMQ$​类型的题目([洞穴勘探](https://www.luogu.com.cn/problem/P2147)、[部落冲突](https://www.luogu.com.cn/problem/P3950))中也可以对查询**时间轴**进行建树，以**边的有效期**进行更新。

## 二维坐标系计数
对于二维坐标系的**点对**贡献处理,例如[Extending Set of Points](https://codeforces.com/problemset/problem/1140/F)，可以将点对 $(x,y)$ 处理成 $x -> y + n$ 的边，此时，这个坐标系的变成了一张二分图，那么他们的贡献关系变成了 **左子图和右子图的积** ，注意，对于左子图的$siz2$应为0,因为一开始是没有贡献的，反之，右子图也是如此。

设点集 $\mathbf{S}=\{ (1,2),(2,2),(2,4),(1,4) \}$,范围为 $5$x$5$​
![坐标系转换](https://raw.githubusercontent.com/ManInM00N/Pics/main/%E6%88%AA%E5%9B%BE%202024-07-24%2015-14-31.png)

```cpp
bool merge(int x, int y){
    x = find(x);
    y = find(y);
    if (x == y)
        return false;
    if (siz[x] < siz[y])
        std::swap(x,y);
    ans-=siz1[x] * siz2[x] + siz1[y] *siz2[y];// 减去之前的和
    stk.push({y,siz[x]});
    siz[x] += siz[x]==siz[y];
    siz1[x] += siz1[y];
    siz2[x]+=siz2[y];
    ans +=siz1[x]*siz2[x];// 加上新的和
    f[y] = x;
    limit++;
    return true;
}
ll roll_back(ll req = 1e9){
    while (!stk.empty()&&req>0){
        auto [x,_] = stk.top();
        stk.pop();
        limit--;
        req--;
        siz[f[x]] = _;
        // 回滚点集大小
        siz1[f[x]]-=siz1[x];
        siz2[f[x]]-=siz2[x];
        f[x] = x;
    }
    return limit;
}
```

